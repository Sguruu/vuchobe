package ru.vuchobe.util.loaders;import android.util.Log;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import java.util.Locale;import java.util.Objects;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;import androidx.annotation.CallSuper;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.annotation.UiThread;import ru.vuchobe.BuildConfig;import ru.vuchobe.util.StoreLastArrayList;import ru.vuchobe.util.threadUtil.ThreadLooper;import ru.vuchobe.util.threadUtil.ThreadService;import ru.vuchobe.util.threadUtil.IThreadTask;import ru.vuchobe.util.threadUtil.ThreadTask;public abstract class PageLoader<ResponseBody, Value> implements Loader<ResponseBody, Value> {    protected Loader parent;    protected long size;    protected @Nullable PageLoader<ResponseBody, Value> longLoader;    protected long timeDoneData = 30 * 1000;    protected ThreadLooper looper;    protected List<Page> statePages = StoreLastArrayList.create(64);    protected Object blockQueue = new Object();    protected LinkedBlockingDeque<PageParams> queue = new LinkedBlockingDeque(20);    protected LinkedBlockingDeque<PageParams> queueLoad = new LinkedBlockingDeque(30);    public PageLoader(            ThreadLooper looper,            long size,            @Nullable PageLoader<ResponseBody, Value> longLoader,            long timeDoneData    ){        this.looper = looper;        this.size = size;        this.timeDoneData = timeDoneData;        this.longLoader = longLoader;        if(this.longLoader != null){            this.longLoader.setParent(this);            this.size = this.longLoader.size;        }    }    @Override    public Status getStatusValue(){        Loader p = this.parent;        if(p != null && p.getLongLoader() == this && p instanceof PageLoader){            PageLoader parent = (PageLoader) p;            return parent.getStatusValue();        }        throw new IllegalArgumentException("parent dn't override getStatusValue()");        //return Status.NOT_LOAD;    }    @Override    public Status getStatusValue(Params params) {        PageParams pageParams = assertPageParams(params);        Loader p = this.parent;        if(p != null && p.getLongLoader() == this && p instanceof PageLoader){            PageLoader parent = (PageLoader) p;            return parent.getStatusValue(pageParams);        }        throw new IllegalArgumentException("parent dn't override getStatusValue(long position)");        //return Status.NOT_LOAD;    }    @Override    public void start() {        hasStart.set(true);        if(this.longLoader != null){            this.longLoader.start();        }    }    @Override    public void pause() {        hasStart.set(false);        if(this.longLoader != null){            this.longLoader.pause();        }    }    @Override    public void stop() {        hasStart.set(false);        if(this.longLoader != null){            this.longLoader.stop();        }    }    @Nullable    @Override    public Loader getLongLoader() { return this.longLoader; }    @Override    @UiThread    public void load(Params params){        if (BuildConfig.DEBUG) Log.d("PageLoader", "START LOAD "+ params);        final PageParams pageParams = assertPageParams(params);        looper.asyncMain((ThreadTask taskMain) -> {            synchronized (blockQueue) {                if(!queue.isEmpty()) load();                if (getStatusValue(params) == Status.DONE) {                    Page page = getPage(pageParams.getPage());                    if (page != null && page.getState() == Status.DONE) {                        return;                    }                }                if (queue.contains(pageParams) || queueLoad.contains(pageParams)) {                    return;                }                while (queue.size() > 10) {                    PageParams pageParams1 = queue.pollLast();                    this.callbackResult(pageParams1, null, null);                }                queue.addFirst(pageParams);                //Если данные устарели, то запросить у long возможно они устарели и там                PageLoader longLoader = this.longLoader;                if(longLoader != null){                    longLoader.load(params);                }            }            //дописать очередь + вызов загрузчика            load();        });    }    protected AtomicBoolean hasStart = new AtomicBoolean(true);    protected AtomicBoolean hasLoad = new AtomicBoolean(false);    protected int MAX_COUNT_RECONNECT = 10;    protected AtomicInteger countReconnect = new AtomicInteger(MAX_COUNT_RECONNECT);    protected void load(){        if (hasStart.get() && queueLoad.size() < 11 && !hasLoad.getAndSet(true)) {            looper.asyncMain((ThreadTask taskMain) -> {                final List<PageParams> list;                synchronized (blockQueue){                    list = new ArrayList<>(queue);                    queueLoad.addAll(queue);                    queue.clear();                }                asyncRun(                        ThreadService.Unique.NONE,                        ThreadService.NONE,                        ThreadService.NONE,                        ThreadService.NONE,                        ThreadService.NONE,                        (ThreadTask task)->{                            for (PageParams param : list){                                if (BuildConfig.DEBUG) Log.d("PageLoader", "LOAD "+ param);                                load(param.getPage(), param.getSize(), param, this);                            }                        }                );                hasLoad.set(false);            });        }    }    protected int uniqueNum = ThreadTask.getUniqueNumGen();    /**     * По умолчанию Network, пр необходимости необходимо переопределнить метод     * protected ThreadTask asyncRun(ThreadService.Unique unique, int uniqueNum, int timeStart, int timeReplay, int count,  IThreadTask task){     *     return ThreadService.get().asyncNetwork(unique, uniqueNum, timeStart, timeReplay, count, task);     * }     * @param unique - уникальность     * @param uniqueNum - номер     * @param timeStart - время старта     * @param timeReplay - время рестарта     * @param count - кол-во перезапусков     * @param task - задача которую необходимо выполнить async и не в главном потоке     */    protected ThreadTask asyncRun(ThreadService.Unique unique, int uniqueNum, int timeStart, int timeReplay, int count,  IThreadTask task){        return ThreadService.get().asyncNetwork(unique, uniqueNum, timeStart, timeReplay, count, task);    }    protected abstract void load(            long page,            long size,            Params params,            @NonNull CallbackResult<ResponseBody, Value> callback    );    @Override    public void callbackResult(            Params params,            ResponseBody responseBody,            List<Value> values    ) {        final PageParams pageParams = assertPageParams(params);        looper.asyncMain((ThreadTask taskMain) ->{            if(values == null){                PageLoader<ResponseBody, Value> longLoader = this.longLoader;                if(longLoader != null){                    longLoader.load(pageParams);                    return;                }            }            updateDataFastLoader(this, pageParams, responseBody, values);            //deleteInQueue            deleteInQueue(pageParams, values);        });    }    @NonNull    @Override    public BuildPageParams buildParams() {        return new BuildPageParams();    }    @Override    public void setParent(@Nullable Loader parent){        this.parent = parent;    }    @UiThread    @Override    public boolean updateDataUI(@Nullable Loader loader, @Nullable Params params) {        Loader parent = this.parent;        if(parent == null || params == null) return true;        if(loader != this.longLoader) {            Params main = null;            if(params.getParent() != null) {                main = params.getParent().clone();                main.setParent(params.getParent().getParent());                main.setChildren(params.clone());                main.getChildren().setParent(null);            }            return parent.updateDataUI(this, main);        }else{            return parent.updateDataUI(this, params);        }    }    @UiThread    public void updateDataFastLoader(             @Nullable Loader loader,             @Nullable Loader.Params params,             @Nullable ResponseBody valueOne,             @NonNull List<Value> value    ){        asyncRun(                ThreadService.Unique.NONE,                ThreadService.NONE,                ThreadService.NONE,                ThreadService.NONE,                ThreadService.NONE,                (ThreadTask task)->{                    final PageParams pageParams = assertPageParams(params);                    save(loader, pageParams, valueOne, value);                    ThreadService.get().asyncMain((ThreadTask taskMain)->{                        Loader parent = this.parent;                        if(parent != null && parent.getLongLoader() == this && parent instanceof PageLoader){                            ((PageLoader)parent).updateDataFastLoader(this, pageParams, valueOne, value);                        }else{                            updateDataUI(this, pageParams);                        }                        //deleteInQueue                        deleteInQueue(pageParams, value);                    });                }        );    }    protected PageParams assertPageParams(Params params){        if (params == null) {            throw new UnsupportedOperationException("PageLoader не поддерживает загрузку c params == null");        }        if (!(params instanceof PageParams)) {            throw new UnsupportedOperationException("PageLoader поддерживает только PageParams");        }        PageParams pageParams = (PageParams) params;        if(pageParams.getPage() < 0 || pageParams.getSize() <= 0){            throw new UnsupportedOperationException("PageLoader поддерживает только Page >= 0 && Size > 1");        }        return pageParams;    }    protected void deleteInQueue(PageParams pageParams, List<Value> values){        if (BuildConfig.DEBUG) Log.d("PageLoader", "removeQueue "+ pageParams);        if(values == null){            if (BuildConfig.DEBUG) Log.e("PageLoader", "END LOAD fail "+ pageParams);            synchronized (blockQueue) {                while (queueLoad.removeLastOccurrence(pageParams)) ;                while (queue.removeLastOccurrence(pageParams)) ;                queue.addLast(pageParams);                             //Добавляем в конец очереди для повтора после ввсего остального (Низкий приоритет загрузки)            }            if(countReconnect.decrementAndGet() > 0){                asyncRun(                        ThreadService.Unique.NEW,                        uniqueNum,                        1000,                        ThreadService.NONE,                        ThreadService.NONE,                        (ThreadTask task) -> load()                );            }        }else{            if (BuildConfig.DEBUG) Log.d("PageLoader", "END LOAD done "+ pageParams);            Page page = getPage(pageParams.getPage());            if(page != null){                page.setState(Status.DONE);            }            synchronized (blockQueue) {                while (queueLoad.removeLastOccurrence(pageParams)) ;                while (queue.removeLastOccurrence(pageParams)) ;            }            countReconnect.set(MAX_COUNT_RECONNECT);            asyncRun(                    ThreadService.Unique.NEW,                    uniqueNum,                    10,                    ThreadService.NONE,                    ThreadService.NONE,                    (ThreadTask task) -> load()            );        }    }    protected Page getPage(long pagePosition){        while(statePages.size() <= pagePosition){            statePages.add(new Page(this.timeDoneData));        }        return statePages.get((int)pagePosition);    }    public static class PageParams implements Params{        private long page;        private long size;        public PageParams(long page, long size){            this.page = page;            this.size = size;        }        public long getPage(){ return page; }        public long getSize(){ return size; }        private Params parent;        @Nullable        @Override        public Params getParent() { return parent; }        @Override        public void setParent(Params parent) { this.parent = parent; }        private Params children;        @Nullable        @Override        public Params getChildren() { return children; }        @Override        public void setChildren(Params children) { this.children = children; }        @Override        public PageParams clone() {            PageParams params = new PageParams(page, size);            params.parent = parent;            params.children = children;            return params;        }        @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            PageParams that = (PageParams) o;            return page == that.page &&                    size == that.size;        }        @Override        public int hashCode() {            return Objects.hash(page, size);        }        @NonNull        @Override        public String toString() {            return String.format(Locale.ROOT,"&page=%d&size=%d", page, size);        }    }    public static class BuildPageParams implements BuildParams{        private long page = 0;        private long size = 0;        private Params parent = null;        public BuildPageParams(){}        public BuildPageParams setPage(long page){            this.page = page;            return this;        }        public BuildPageParams setSize(long size){            this.size = size;            return this;        }        @Override        public BuildParams setObject(Object object) {            throw new UnsupportedOperationException("PageParams не поддерживат внутренюю загрузку");        }        @Override        public BuildParams setKeyMethod(Method keyMethod) {            throw new UnsupportedOperationException("PageParams не поддерживат внутренюю загрузку");        }        @Override        public BuildParams setSetMethod(Method setMethod) {            throw new UnsupportedOperationException("PageParams не поддерживат внутренюю загрузку");        }        @Override        public BuildParams setParent(Params parent) {            this.parent = parent;            return this;        }        @Override        public PageParams build() {            PageParams result = new PageParams(page, size);            result.setParent(parent);            return result;        }    }    private static class Page{        private long timeDoneDate = 30 * 1000;        private long timeNewLoad = 0;        private boolean hasData = false;        private Status state = Status.NOT_LOAD;        Page(long timeDoneDate){            this.timeDoneDate = timeDoneDate;        }        Page(Status state){            this.state = state;            this.timeNewLoad = Long.MAX_VALUE;        }        public void setState(Status state){            if(state == Status.DONE){                this.timeNewLoad = System.currentTimeMillis() + timeDoneDate;            }            this.state = state;        }        public Status getState(){ testPageState(); return state; }        public void setTimeNewLoad(long time){ this.timeNewLoad = time; }        public long getTimeNewLoad(){ testPageState(); return timeNewLoad; }        public boolean hasData(){ testPageState(); return hasData; }        private void testPageState(){            if(state == Status.DONE && timeNewLoad < System.currentTimeMillis()){                state = Status.OUTDATED;            }            if(state == Status.DONE || state == Status.OUTDATED){                hasData = true;            }        }    }}