package ru.vuchobe.util.loaders;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import ru.vuchobe.util.threadUtil.ThreadLooper;public class ObjectSaveResult<ResponseBody, Value> extends ObjectLoader<ResponseBody, Value> implements SaveResult<ResponseBody, Value> {    protected Method methodKeyLoad;    protected Method methodSetLoad;    protected List<SaveResult> loaders;    protected ResponseBody responseBody;    protected final Object blockValues = new Object();    protected HashMap<Object, Storage<Value>> values = new HashMap<>();    protected long saveValue;    public ObjectSaveResult(            ThreadLooper looper,            @Nullable Method methodKeyLoad,            @Nullable Method methodSetLoad,            @Nullable ObjectLoader<ResponseBody, Value> longLoader,            @Nullable List<SaveResult> loaders,            long timeDoneData,            int saveValue    ){        super(looper, longLoader, timeDoneData);        this.methodKeyLoad = methodKeyLoad;        this.methodSetLoad = methodSetLoad;        this.loaders = loaders;        if(this.loaders != null){            for(SaveResult loader : this.loaders){                loader.setParent(this);            }        }else{            this.loaders = Collections.EMPTY_LIST;        }        if(saveValue < 0) saveValue = 1;        if(saveValue > 1024) saveValue = 1024;        this.saveValue = saveValue;    }    @Nullable    public ResponseBody getValue(){        return null;    }    @Nullable    public Value getValue(long position){        return null;    }    @Nullable    @Override    public Value getValue(Params params) {        ObjectParams objParams = assertObjectParams(params);        if(objParams.getObject() == null || objParams.getKeyMethod() == null || objParams.getSetMethod() == null){            throw new UnsupportedOperationException("ListPage для getValue должен содержать ids, object, keyMethod, setMethod ");        }        if(objParams.getIds() == null || objParams.getIds().isEmpty()) return null;        ArrayList<Object> idsResult = new ArrayList<>();        ArrayList<Value> result = new ArrayList<>();        for(ObjectParams p : objParams.getListParams()){            Object id = p.getIds().get(0);            if(id == null) continue;            Storage<Value> storage = values.get(id);            if(storage == null){                load(p.clone());                continue;            }            clearValues(id);            if(storage.getValue() == null){ continue; }            Status status = getStatusValue(p);            if(status == Status.NOT_LOAD || status == Status.OUTDATED){ load(p.clone()); }            Value value = storage.getValue();            if(value instanceof ResultClonable) {                value = (Value) ((ResultClonable)value).clone();            }            //Объединение результата            for (SaveResult saveResult : this.loaders) {                Params newParams = saveResult.buildParams()                        .setObject(value)                        .setKeyMethod(saveResult.getKeyMethod())                        .setSetMethod(saveResult.getSetMethod())                        .setParent(params)                        .build();                saveResult.getValue(newParams);            }            idsResult.add(id);            result.add(value);        }        try {            Object object = objParams.getObject();            Method keyMethod = objParams.getKeyMethod();            Method setMethod = objParams.getSetMethod();            Class clazzResultId = keyMethod.getReturnType();            Class clazzObject = setMethod.getParameterTypes()[0];            if (clazzResultId.isArray() && clazzObject.isArray()) {                setMethod.invoke(object, result.toArray());            } else if (List.class.isAssignableFrom(clazzResultId) && List.class.isAssignableFrom(clazzObject)) {                setMethod.invoke(object, result);            } else if (List.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                HashMap<Object, Value> map = new HashMap<>();                for(int i = 0; i < result.size(); i++){                    map.put(idsResult.get(i), result.get(i));                }                setMethod.invoke(object, map);            } else if (Map.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                HashMap<Object, Value> map = new HashMap<>();                for(int i = 0; i < result.size(); i++){                    map.put(idsResult.get(i), result.get(i));                }                setMethod.invoke(object, map);            } else {                if(result.size() > 0) setMethod.invoke(object, result.get(0));            }        } catch (IllegalAccessException | InvocationTargetException e) {            e.printStackTrace();        }        return (result.size() > 0) ? result.get(0) : null;    }    @Override    public Status getStatusValue(){        return (responseBody == null)? Status.NOT_LOAD : Status.OUTDATED;    }    @Override    public Status getStatusValue(Params params) {        ObjectParams pageParams = assertObjectParams(params);        long time = System.currentTimeMillis();        for(Object id : pageParams.getIds()){            if(id == null) continue;            Storage storage = values.get(id);            if(storage == null || storage.value == null) return Status.NOT_LOAD;            if(storage.getTimeLoad() + timeDoneData < time){                return Status.OUTDATED;            }        }        return Status.DONE;    }    @Override    public void load(Params params) {        ObjectLoader longLoader = this.longLoader;        if(longLoader != null){            longLoader.load(params);        }else{            throw new UnsupportedOperationException("ObjectSaveResult не поддерживает загрузку данных, установите longLoader");        }    }    @Override    protected void load() { }    @Override    protected void load(Object id, Params params, @NonNull CallbackResult<ResponseBody, Value> callback) { }    @Override    public void save(            @Nullable Loader loader,            @Nullable Params params,            @Nullable ResponseBody responseBody,            @NonNull List<Value> values    ) {        if(params instanceof ObjectParams) {            //updateData            ObjectParams objectParams = (ObjectParams) params;            Storage<Value> storage = this.values.get(objectParams.getIds().get(0));            if(storage == null){                storage = new Storage<>(null);                this.values.put(objectParams.getIds().get(0), storage);            }            if(!values.isEmpty()) {                Value v = values.get(0);                storage.setValue(v);                //LoadValues all                for (SaveResult saveResult : this.loaders) {                    Params newParams = saveResult.buildParams()                            .setObject(v)                            .setKeyMethod(saveResult.getKeyMethod())                            .setSetMethod(saveResult.getSetMethod())                            .setParent(params)                            .build();                    saveResult.load(newParams);                }            }            if(responseBody != null){ this.responseBody = responseBody; }        }    }    @Override    public boolean updateDataUI(@Nullable Loader loader, @Nullable Params params) {        if(params instanceof ObjectParams && params.getChildren() == null) {            ObjectParams objectParams = (ObjectParams) params;            Storage<Value> storage = this.values.get(objectParams.getIds().get(0));            if(storage != null && !storage.getAndClearUpdateUI()) return false;        }        return super.updateDataUI(loader, params);    }    @Override    public void start() {        super.start();        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.start();            }        }        List<Object> ids;        synchronized (blockValues){            for(Storage storage : values.values()){                storage.timeLoad = 1;            }            ids = new ArrayList<>(values.keySet());        }        load(buildParams().setIds(ids).build());    }    @Override    public void pause() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.pause();            }        }        super.pause();    }    @Override    public void stop() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.stop();            }        }        values.clear();        super.stop();    }    @Override    public Method getKeyMethod() {        return this.methodKeyLoad;    }    @Override    public Method getSetMethod() {        return this.methodSetLoad;    }    protected void clearValues(Object id){        synchronized (blockValues) {            Storage<Value> storage = values.get(id);            if (storage != null) {                storage.incUseCount();                if(storage.getUseCount() < -1000000){                    long useCount = -storage.getUseCount();                    for(Storage st : values.values()){ st.useCount += useCount; }                }            }            if (values.size() > saveValue) {                ArrayList<Storage> list = new ArrayList<>(values.values());                for(Storage st : list){ st.decUseCount(); }                long time = System.currentTimeMillis();                Comparator<Storage> comparator = (o1, o2) -> {                    if(o1.timeLoad + o1.timeSave > time ^ o2.timeLoad + o2.timeSave > time){                        return (o1.timeLoad + o1.timeSave > time) ? 1 : -1;                    }                    return (int)(o1.useCount - o2.useCount);                };                Collections.sort(list, comparator);                List<Storage> deletes = list.subList(0, list.size() - (int)saveValue);                values.values().removeAll(deletes);                if(id != null && storage != null){                    values.put(id, storage);                }            }            if(values.size() > saveValue * 2){                values.clear();            }        }    }    protected static class Storage<Value>{        private long timeLoad;        private long useCount;        private boolean updateUI = false;        private Value value;        public Storage(Value value){            this.value = value;            this.timeLoad = System.currentTimeMillis();            this.useCount = 1;        }        public long getTimeLoad() {            return timeLoad;        }        public long getUseCount() {            return useCount;        }        public void incUseCount(){            useCount++;        }        public void decUseCount(){            useCount--;        }        public Value getValue() {            return value;        }        public boolean isUpdateUI() { return updateUI; }        public boolean getAndClearUpdateUI(){            boolean result = updateUI;            updateUI = false;            return result;        }        public void setValue(Value value) {            if(value != null) {                this.timeLoad = System.currentTimeMillis();            }            updateUI = (value != null) && !value.equals(this.value);            this.value = value;        }        private final long timeSave = 500;    }}