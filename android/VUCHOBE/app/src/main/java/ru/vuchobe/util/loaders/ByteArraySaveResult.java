package ru.vuchobe.util.loaders;import android.util.Log;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Objects;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import ru.vuchobe.BuildConfig;import ru.vuchobe.service.NetworkManager;import ru.vuchobe.util.NetworkUtils;import ru.vuchobe.util.threadUtil.ThreadLooper;import ru.vuchobe.util.threadUtil.ThreadService;import ru.vuchobe.util.threadUtil.ThreadTask;public abstract class ByteArraySaveResult<ResponseBody, Value> extends ObjectLoader<ResponseBody, InputStream> implements SaveResult<ResponseBody, Value> {    protected Method methodKeyLoad;    protected Method methodSetLoad;    protected List<SaveResult> loaders;    protected ResponseBody responseBody;    protected final Object blockValues = new Object();    protected HashMap<Object, Storage> values = new HashMap<>();    protected long saveValue;    public ByteArraySaveResult(            ThreadLooper looper,            @Nullable Method methodKeyLoad,            @Nullable Method methodSetLoad,            @Nullable ObjectLoader<ResponseBody, InputStream> longLoader,            @Nullable List<SaveResult> loaders,            long timeDoneData,            int saveValue    ){        super(looper, longLoader, timeDoneData);        this.methodKeyLoad = methodKeyLoad;        this.methodSetLoad = methodSetLoad;        this.loaders = loaders;        if(this.loaders != null){            for(SaveResult loader : this.loaders){                loader.setParent(this);            }        }else{            this.loaders = Collections.EMPTY_LIST;        }        if(saveValue < 0) saveValue = 1;        if(saveValue > 1024) saveValue = 1024;        this.saveValue = saveValue;    }    @Nullable    public ResponseBody getValue(){        return null;    }    @Nullable    public Value getValue(long position){        return null;    }    @Nullable    @Override    public Value getValue(Params params) {        ObjectParams objParams = assertObjectParams(params);        if(objParams.getObject() == null || objParams.getKeyMethod() == null || objParams.getSetMethod() == null){            throw new UnsupportedOperationException("ListPage для getValue должен содержать ids, object, keyMethod, setMethod ");        }        if(objParams.getIds() == null || objParams.getIds().isEmpty()) return null;        ArrayList<Object> idsResult = new ArrayList<>();        ArrayList<Value> result = new ArrayList<>();        for(ObjectParams p : objParams.getListParams()){            Object id = p.getIds().get(0);            if(id == null) continue;            Storage storage = values.get(id);            if(storage == null){                load(p.clone());                continue;            }            clearValues(id);            if(storage.getValue() == null){ continue; }            Status status = getStatusValue(p);            if(status == Status.NOT_LOAD || status == Status.OUTDATED){ load(p.clone()); }            Value value = convert(storage.getValue());            for (SaveResult saveResult : this.loaders) {                Params newParams = saveResult.buildParams()                        .setObject(value)                        .setKeyMethod(saveResult.getKeyMethod())                        .setSetMethod(saveResult.getSetMethod())                        .setParent(params)                        .build();                saveResult.getValue(newParams);            }            idsResult.add(id);            result.add(value);        }        try {            Object object = objParams.getObject();            Method keyMethod = objParams.getKeyMethod();            Method setMethod = objParams.getSetMethod();            Class clazzResultId = keyMethod.getReturnType();            Class clazzObject = setMethod.getParameterTypes()[0];            if (clazzResultId.isArray() && clazzObject.isArray()) {                setMethod.invoke(object, result.toArray());            } else if (List.class.isAssignableFrom(clazzResultId) && List.class.isAssignableFrom(clazzObject)) {                setMethod.invoke(object, result);            } else if (List.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                HashMap<Object, Value> map = new HashMap<>();                for(int i = 0; i < result.size(); i++){                    map.put(idsResult.get(i), result.get(i));                }                setMethod.invoke(object, map);            } else if (Map.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                HashMap<Object, Value> map = new HashMap<>();                for(int i = 0; i < result.size(); i++){                    map.put(idsResult.get(i), result.get(i));                }                setMethod.invoke(object, map);            } else {                if(result.size() > 0) setMethod.invoke(object, result.get(0));            }        } catch (IllegalAccessException | InvocationTargetException e) {            e.printStackTrace();        }        return (result.size() > 0) ? result.get(0) : null;    }    @Override    public Status getStatusValue(){        return (responseBody == null)? Status.NOT_LOAD : Status.OUTDATED;    }    @Override    public Status getStatusValue(Params params) {        ObjectParams pageParams = assertObjectParams(params);        long time = System.currentTimeMillis();        for(Object id : pageParams.getIds()){            if(id == null) continue;            Storage storage = values.get(id);            if(storage == null || storage.value == null) return Status.NOT_LOAD;            if(storage.getTimeLoad() + timeDoneData < time){                return Status.OUTDATED;            }        }        return Status.DONE;    }    @Override    public void load(Params params) {        ObjectLoader longLoader = this.longLoader;        if(longLoader != null){            List<Object> ids = assertObjectParams(params).getIds();            if(ids != null){                for(Object id : ids){                    Storage storage = this.values.get(id);                    if(storage == null){                        this.values.put(id, new Storage(null));                    }                }            }            longLoader.load(params);        }else{            throw new UnsupportedOperationException("ObjectSaveResult не поддерживает загрузку данных, установите longLoader");        }    }    @Override    protected void load() { }    @Override    protected void load(Object id, Params params, @NonNull CallbackResult<ResponseBody, InputStream> callback) { }    @Override    public void save(            @Nullable Loader loader,            @Nullable Params params,            @Nullable ResponseBody responseBody,            @Nullable List<InputStream> values    ) {        if(params instanceof ObjectParams) {            if (BuildConfig.DEBUG)  Log.d("ByteArraySaveResult", "START SAVE "+ params);            //updateData            ObjectParams objectParams = (ObjectParams) params;            Storage storagetmp = this.values.get(objectParams.getIds().get(0));            if(storagetmp == null){                storagetmp = new Storage(null);                this.values.put(objectParams.getIds().get(0), storagetmp);            }            final Storage storage = storagetmp;            if(values != null && !values.isEmpty()) {                InputStream inputStream = values.get(0);                if(inputStream != null){                    //Узнаем длину если возможно                    int l = 0;                    if(inputStream instanceof ByteArrayInputStream){                        try {                            l = inputStream.available();                        } catch (IOException e) { e.printStackTrace(); }                    }else if(inputStream instanceof NetworkUtils.ProgressInputStream){                        l = (int)((NetworkUtils.ProgressInputStream) inputStream).getSizeData();                    }                    if (BuildConfig.DEBUG)  Log.d("ByteArraySaveResult", "SAVE SIZE "+ params + " size= " + l);                    if (l <= 0) l = 64;                    //Создаем buffer                    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(l);                    final long timeLoad = storage.timeLoad;                    NetworkUtils.LoadBytes loaded = new NetworkUtils.LoadBytes(){                        @Override                        public void load(byte[] bytes, int start, int count) {                            if (BuildConfig.DEBUG)  Log.d("ByteArraySaveResult", "SAVE LOAD SIZE "+ params + " size= " + count);                            storage.timeLoad = System.currentTimeMillis();                            outputStream.write(bytes, start, count);                        }                        @Override                        public void finish() {                            if (BuildConfig.DEBUG)  Log.d("ByteArraySaveResult", "SAVE END finish() "+ params);                            if (BuildConfig.DEBUG)  Log.d("ByteArraySaveResult", "SAVE END finish() parent "+ params.getParent());                            byte[] bytes = outputStream.toByteArray();                            looper.asyncMain((ThreadTask task)->{                                Storage storagetmp = ByteArraySaveResult.this.values.get(objectParams.getIds().get(0));                                if(storagetmp == null){                                    storagetmp = new Storage(null);                                    ByteArraySaveResult.this.values.put(objectParams.getIds().get(0), storagetmp);                                }                                saveResult(bytes, storagetmp, objectParams);                            });                        }                        @Override                        public void fail(Exception ex) {                            if (BuildConfig.DEBUG) Log.d("ByteArraySaveResult", "SAVE END fail() "+ params);                            storage.timeLoad = timeLoad;                            //if(outputStream.size() > 0){ finish(); }                        }                    };                    //запуск                    asyncRun(                            ThreadService.Unique.NONE,                            ThreadService.NONE,                            ThreadService.NONE,                            0, Integer.MAX_VALUE,                            NetworkUtils.loadStream(inputStream, loaded)                    );                }                //saveResult            }            if(responseBody != null){ this.responseBody = responseBody; }        }    }    public abstract Value convert(byte[] bytes);    private void saveResult(byte[] v, Storage storage, ObjectParams objectParams){        if(v != null) {            storage.setValue(v);            //LoadValues all            for (SaveResult saveResult : this.loaders) {                Params newParams = saveResult.buildParams()                        .setObject(v)                        .setKeyMethod(saveResult.getKeyMethod())                        .setSetMethod(saveResult.getSetMethod())                        .setParent(objectParams)                        .build();                saveResult.load(newParams);            }            updateDataUI(this, objectParams);        }    }    @Override    public boolean updateDataUI(@Nullable Loader loader, @Nullable Params params) {        if(params instanceof ObjectParams && params.getChildren() == null) {            ObjectParams objectParams = (ObjectParams) params;            Storage storage = this.values.get(objectParams.getIds().get(0));            if(storage != null && !storage.getAndClearUpdateUI()) return false;        }        return super.updateDataUI(loader, params);    }    @Override    public void start() {        super.start();        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.start();            }        }        List<Object> ids;        synchronized (blockValues){            for(Storage storage : values.values()){                storage.timeLoad = 1;            }            ids = new ArrayList<>(values.keySet());        }        load(buildParams().setIds(ids).build());    }    @Override    public void pause() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.pause();            }        }        super.pause();    }    @Override    public void stop() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.stop();            }        }        values.clear();        super.stop();    }    @Override    public Method getKeyMethod() {        return this.methodKeyLoad;    }    @Override    public Method getSetMethod() {        return this.methodSetLoad;    }    protected void clearValues(Object id){        synchronized (blockValues) {            Storage storage = values.get(id);            if (storage != null) {                storage.incUseCount();                if(storage.getUseCount() < -1000000){                    long useCount = -storage.getUseCount();                    for(Storage st : values.values()){ st.useCount += useCount; }                }            }            if (values.size() > saveValue) {                ArrayList<Storage> list = new ArrayList<>(values.values());                for(Storage st : list){ st.decUseCount(); }                long time = System.currentTimeMillis();                Comparator<Storage> comparator = (o1, o2) -> {                    if(o1.timeLoad + o1.timeSave > time ^ o2.timeLoad + o2.timeSave > time){                        return (o1.timeLoad + o1.timeSave > time) ? 1 : -1;                    }                    return (int)(o1.useCount - o2.useCount);                };                Collections.sort(list, comparator);                List<Storage> deletes = list.subList(0, list.size() - (int)saveValue);                values.values().removeAll(deletes);                if(id != null && storage != null){                    values.put(id, storage);                }            }            if(values.size() > saveValue * 2){                values.clear();            }        }    }    protected static class Storage{        private long timeLoad;        private long useCount;        private boolean updateUI = false;        private byte[] value;        public Storage(byte[] value){            this.value = value;            this.timeLoad = System.currentTimeMillis();            this.useCount = 1;        }        public long getTimeLoad() {            return timeLoad;        }        public long getUseCount() {            return useCount;        }        public void incUseCount(){            useCount++;        }        public void decUseCount(){            useCount--;        }        public byte[] getValue() {            return value;        }        public boolean isUpdateUI() { return updateUI; }        public boolean getAndClearUpdateUI(){            boolean result = updateUI;            updateUI = false;            return result;        }        public void setValue(byte[] value) {            if(value != null) {                this.timeLoad = System.currentTimeMillis();            }            updateUI = (value != null) && Arrays.equals(value, this.value);            this.value = value;        }        private final long timeSave = 500;    }}