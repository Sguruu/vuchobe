package ru.vuchobe.util.loaders;import android.util.Log;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Objects;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.annotation.UiThread;import ru.vuchobe.BuildConfig;import ru.vuchobe.util.NetworkUtils;import ru.vuchobe.util.threadUtil.IThreadTask;import ru.vuchobe.util.threadUtil.ThreadLooper;import ru.vuchobe.util.threadUtil.ThreadService;import ru.vuchobe.util.threadUtil.ThreadTask;public abstract class ObjectLoader<ValueOne, Value> implements Loader<ValueOne, Value> {    protected Loader parent;    protected @Nullable    ObjectLoader<ValueOne, Value> longLoader;    protected long timeDoneData = 30 * 1000;    protected ThreadLooper looper;    protected HashMap<Object, Page> statePages = new HashMap<>();    protected Object blockQueue = new Object();    protected LinkedBlockingDeque<ObjectParams> queue = new LinkedBlockingDeque(30);    protected LinkedBlockingDeque<ObjectParams> queueLoad = new LinkedBlockingDeque(30);    public ObjectLoader(            ThreadLooper looper,            @Nullable ObjectLoader<ValueOne, Value> longLoader,            long timeDoneData    ){        this.looper = looper;        this.timeDoneData = timeDoneData;        this.longLoader = longLoader;        if(this.longLoader != null){            this.longLoader.setParent(this);        }    }    @Override    public Status getStatusValue(){        Loader p = this.parent;        if(p != null && p.getLongLoader() == this && p instanceof ObjectLoader){            ObjectLoader parent = (ObjectLoader) p;            return parent.getStatusValue();        }        throw new IllegalArgumentException("parent dn't override getStatusValue()");        //return Status.NOT_LOAD;    }    @Override    public Status getStatusValue(Params params) {        ObjectParams objectParams = assertObjectParams(params);        Loader p = this.parent;        if(p != null && p.getLongLoader() == this && p instanceof ObjectLoader){            ObjectLoader parent = (ObjectLoader) p;            return parent.getStatusValue(objectParams);        }        throw new IllegalArgumentException("parent dn't override getStatusValue(long position)");        //return Status.NOT_LOAD;    }    @Override    public void start() {        hasStart.set(true);        if(this.longLoader != null){            this.longLoader.start();        }    }    @Override    public void pause() {        hasStart.set(false);        if(this.longLoader != null){            this.longLoader.pause();        }    }    @Override    public void stop() {        hasStart.set(false);        if(this.longLoader != null){            this.longLoader.stop();        }    }    @Nullable    @Override    public Loader getLongLoader() { return this.longLoader; }    @Override    @UiThread    public void load(Params params){        if (BuildConfig.DEBUG) Log.d("ObjectLoader", "START LOAD "+ params);        final ObjectParams objectParams = assertObjectParams(params);        looper.asyncMain((ThreadTask taskMain) -> {            synchronized (blockQueue) {                if(!queue.isEmpty()) load();                for(ObjectParams objectParams1 : objectParams.getListParams()) {                    if (getStatusValue(objectParams1) == Status.DONE) {                        Page page = getPage(objectParams1.getIds());                        if (page != null && page.getState() == Status.DONE) {                            continue;                        }                    }                    if (queue.contains(objectParams1) || queueLoad.contains(objectParams1)) {                        continue;                    }                    while (queue.size() + queueLoad.size() > 10 && queue.size() > 1) {                        ObjectParams objectParams2 = queue.pollLast();                        this.callbackResult(objectParams2, null, null);                    }                    if(objectParams1.getIds() != null && !objectParams1.getIds().isEmpty() && objectParams1.getIds().get(0) != null) {                        queue.addFirst(objectParams1);                    }                }                //Если данные устарели, то запросить у long возможно они устарели и там                ObjectLoader longLoader = this.longLoader;                if (longLoader != null) {                    longLoader.load(params);                }            }            //дописать очередь + вызов загрузчика            load();        });    }    protected AtomicBoolean hasStart = new AtomicBoolean(true);    protected AtomicBoolean hasLoad = new AtomicBoolean(false);    protected int MAX_COUNT_RECONNECT = 10;    protected AtomicInteger countReconnect = new AtomicInteger(MAX_COUNT_RECONNECT);    protected void load(){        if (hasStart.get() && queueLoad.size() < 5 && !hasLoad.getAndSet(true)) {            looper.asyncMain((ThreadTask taskMain) -> {                final List<ObjectParams> list;                synchronized (blockQueue){                    list = new ArrayList<>(queue);                    queueLoad.addAll(queue);                    queue.clear();                }                asyncRun(ThreadService.Unique.NONE, ThreadService.NONE, ThreadService.NONE, ThreadService.NONE, ThreadService.NONE, (ThreadTask task)->{                    List<ObjectParams> sublist = list;                    for (ObjectParams param : sublist){                        if (BuildConfig.DEBUG) Log.d("ObjectLoader", "LOAD "+ param);                        load(param.getIds().get(0), param, this);                    }                    hasLoad.set(false);                });            });        }    }    protected int uniqueNum = ThreadTask.getUniqueNumGen();    /**     * По умолчанию Network, пр необходимости необходимо переопределнить метод     * protected ThreadTask asyncRun(ThreadService.Unique unique, int uniqueNum, int timeStart, int timeReplay, int count,  IThreadTask task){     *     return ThreadService.get().asyncNetwork(unique, uniqueNum, timeStart, timeReplay, count, task);     * }     * @param unique - уникальность     * @param uniqueNum - номер     * @param timeStart - время старта     * @param timeReplay - время рестарта     * @param count - кол-во перезапусков     * @param task - задача которую необходимо выполнить async и не в главном потоке     */    protected ThreadTask asyncRun(ThreadService.Unique unique, int uniqueNum, int timeStart, int timeReplay, int count,  IThreadTask task){        return ThreadService.get().asyncNetwork(unique, uniqueNum, timeStart, timeReplay, count, task);    }    protected abstract void load(            Object id,            Params params,            @NonNull CallbackResult<ValueOne, Value> callback    );    @Override    public void callbackResult(            Params params,            ValueOne responseBody,            List<Value> values    ) {        final ObjectParams pageParams = assertObjectParams(params);        looper.asyncMain((ThreadTask taskMain) ->{            if(values == null){                ObjectLoader<ValueOne, Value> longLoader = this.longLoader;                if(longLoader != null){                    longLoader.load(pageParams);                    return;                }            }            if(values != null && !values.isEmpty() && values.get(0) instanceof InputStream){                for(InputStream inputStream : (List<InputStream>) values){                    if(!(inputStream instanceof NetworkUtils.ProgressInputStream)){                        inputStream = new NetworkUtils.ProgressInputStream(inputStream, -1);                    }                    NetworkUtils.ProgressInputStream progressInputStream = (NetworkUtils.ProgressInputStream) inputStream;                    progressInputStream.addEventLoad(new NetworkUtils.LoadBytes() {                        @Override                        public void load(byte[] bytes, int start, int count) {}                        @Override                        public void finish() {                            //deleteInQueue                            deleteInQueue(pageParams, Collections.EMPTY_LIST);                        }                        @Override                        public void fail(Exception ex) {                            //deleteInQueue                            deleteInQueue(pageParams, null);                        }                    });                }                updateDataFastLoader(this, pageParams, responseBody, values);            }else{                updateDataFastLoader(this, pageParams, responseBody, values);                //deleteInQueue                deleteInQueue(pageParams, values);            }        });    }    @NonNull    @Override    public BuildListParams buildParams() {        return new BuildListParams();    }    @Override    public void setParent(@Nullable Loader parent){        this.parent = parent;    }    @UiThread    @Override    public boolean updateDataUI(@Nullable Loader loader, @Nullable Params params) {        Loader parent = this.parent;        if(parent == null || params == null) return true;        if(loader != this.longLoader) {            Params main = null;            if(params.getParent() != null) {                main = params.getParent().clone();                main.setParent(params.getParent().getParent());                main.setChildren(params.clone());                main.getChildren().setParent(null);            }            return parent.updateDataUI(this, main);        }else{            return parent.updateDataUI(this, params);        }    }    @UiThread    public void updateDataFastLoader(            @Nullable Loader loader,            @Nullable Loader.Params params,            @Nullable ValueOne valueOne,            @Nullable List<Value> value    ){        asyncRun(ThreadService.Unique.NONE, ThreadService.NONE, ThreadService.NONE, ThreadService.NONE, ThreadService.NONE, (ThreadTask task)->{            final ObjectParams objectParams = assertObjectParams(params);            save(loader, objectParams, valueOne, value);            ThreadService.get().asyncMain((ThreadTask taskMain)->{                Loader parent = this.parent;                if(parent != null && parent.getLongLoader() == this && parent instanceof ObjectLoader){                    ((ObjectLoader)parent).updateDataFastLoader(this, objectParams, valueOne, value);                }else{                    updateDataUI(this, objectParams);                }                //deleteInQueue                deleteInQueue(objectParams, value);            });        });    }    protected ObjectParams assertObjectParams(Params params){        if (params == null) {            throw new UnsupportedOperationException("ObjectLoader не поддерживает загрузку c params == null");        }        if (!(params instanceof ObjectLoader.ObjectParams)) {            throw new UnsupportedOperationException("ObjectLoader поддерживает только ObjectParams");        }        ObjectParams objectParams = (ObjectParams) params;        return objectParams;    }    protected void deleteInQueue(ObjectParams objectParams, List<Value> values){        if(values != null && !values.isEmpty() && values.get(0) instanceof InputStream){            return;        }        if (BuildConfig.DEBUG) Log.d("ObjectLoader", "deleteInQueue "+ objectParams);        if(countReconnect.decrementAndGet() > 0){            ThreadTask threadTask = asyncRun(                    ThreadService.Unique.NEW,                    uniqueNum,                    1000,                    ThreadService.NONE,                    ThreadService.NONE,                    (ThreadTask task) -> load()            );        }        if(values == null){            if (BuildConfig.DEBUG) Log.e("ObjectLoader", "END LOAD fail "+ objectParams);            synchronized (blockQueue) {                while (queueLoad.removeLastOccurrence(objectParams)) ;                while (queue.removeLastOccurrence(objectParams)) ;                queue.addLast(objectParams);                             //Добавляем в конец очереди для повтора после ввсего остального (Низкий приоритет загрузки)            }            if(countReconnect.decrementAndGet() > 0){                ThreadTask threadTask = asyncRun(                        ThreadService.Unique.NEW,                        uniqueNum,                        500,                        ThreadService.NONE,                        ThreadService.NONE,                        (ThreadTask task) -> load()                );            }        }else{            if (BuildConfig.DEBUG) Log.d("ObjectLoader", "END LOAD done "+ objectParams);            Page page = getPage(objectParams.getIds());            if(page != null){                page.setState(Status.DONE);            }            synchronized (blockQueue) {                while (queueLoad.removeLastOccurrence(objectParams)) ;                while (queue.removeLastOccurrence(objectParams)) ;            }            countReconnect.set(MAX_COUNT_RECONNECT);            ThreadTask threadTask = asyncRun(                    ThreadService.Unique.NEW,                    uniqueNum,                    10,                    ThreadService.NONE,                    ThreadService.NONE,                    (ThreadTask task) -> load()            );        }    }    protected Page getPage(List<Object> ids){        if(ids == null || ids.isEmpty()) return null;        if(statePages.size() > 100){            Iterator<Map.Entry<Object, Page>> iteration = statePages.entrySet().iterator();            while(iteration.hasNext()){                Map.Entry<Object, Page> entity = iteration.next();                if(entity.getValue().getState() != Status.DONE){                    iteration.remove();                }            }        }        Page value = statePages.get(ids.get(0));        if(statePages.size() > 100){            int remove = statePages.size() - 100;            Iterator<Map.Entry<Object, Page>> iteration = statePages.entrySet().iterator();            while(iteration.hasNext()){                iteration.next();                if(remove-- >= 0){ iteration.remove(); }            }        }        if(value == null){            value = new Page(this.timeDoneData);            statePages.put(ids.get(0), value);        }        return value;    }    public static class ObjectParams implements Params{        private Object object;        private Method keyMethod;        private Method setMethod;        private List<Object> ids;        public ObjectParams(Object object, Method keyMethod, Method setMethod, List<Object> ids){            this.object = object;            this.keyMethod = keyMethod;            this.setMethod = setMethod;            this.ids = ids;        }        public Object getObject() { return object; }        public Method getKeyMethod() { return keyMethod; }        public Method getSetMethod() { return setMethod; }        public List<Object> getIds(){ return ids; }        public List<ObjectParams> getListParams(){            if(ids.size() <= 1) return Collections.singletonList(this);            ArrayList<ObjectParams> list = new ArrayList<>();            for(Object id : ids){                ObjectParams r = new ObjectParams(object, keyMethod, setMethod, Collections.singletonList(id));                Params parent = this.parent;                Params now = r;                while (parent != null){                    now.setParent(parent.clone());                    parent = parent.getParent();                }                if(children != null) r.children = children;                list.add(r);            }            return list;        }        private Params parent;        @Nullable        @Override        public Params getParent() { return parent; }        @Override        public void setParent(Params parent) { this.parent = parent; }        private Params children;        @Nullable        @Override        public Params getChildren() { return children; }        @Override        public void setChildren(Params children) { this.children = children; }        @Override        public ObjectParams clone() {            ObjectParams params = new ObjectParams(object, keyMethod, setMethod, ids);            params.parent = parent;            params.children = children;            return params;        }        @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            ObjectParams that = (ObjectParams) o;            return Objects.equals(ids, that.ids);        }        @Override        public int hashCode() {            return Objects.hash(ids);        }        @NonNull        @Override        public String toString() {            return String.format(Locale.ROOT,"&ids=%s", ids.toString());        }    }    public static class BuildListParams implements BuildParams{        private Object object = null;        private Method keyMethod = null;        private Method setMethod = null;        private List<Object> ids = null;        private Params parent = null;        public BuildListParams(){}        public BuildListParams setObject(Object object){            this.object = object;            return this;        }        public BuildListParams setKeyMethod(Method keyMethod){            this.keyMethod = keyMethod;            return this;        }        public BuildListParams setSetMethod(Method setMethod){            this.setMethod = setMethod;            return this;        }        public BuildListParams setIds(List<Object> ids){            this.ids = ids;            return this;        }        @Override        public BuildParams setParent(Params parent) {            this.parent = parent;            return this;        }        @Override        public ObjectParams build() {            if((ids == null) && (object == null || keyMethod == null || setMethod == null || setMethod.getParameterTypes().length != 1)){                throw new UnsupportedOperationException("ListPage должен содержать ids или object, keyMethod, setMethod ");            }            try {                if (ids == null) {                    Class clazzResultId = keyMethod.getReturnType();                    Class clazzObject = setMethod.getParameterTypes()[0];                    if (clazzResultId.isArray() && clazzObject.isArray()) {                        ids = Arrays.asList((Object[]) keyMethod.invoke(object));                    } else if (List.class.isAssignableFrom(clazzResultId) && List.class.isAssignableFrom(clazzObject)) {                        ids = (List) keyMethod.invoke(object);                    } else if (List.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                        ids = (List) keyMethod.invoke(object);                    } else if (Map.class.isAssignableFrom(clazzResultId) && Map.class.isAssignableFrom(clazzObject)) {                        ids = new ArrayList(((Map) keyMethod.invoke(object)).keySet());                    } else {                        ids = new ArrayList<>();                        ids.add(keyMethod.invoke(object));                    }                }            } catch (IllegalAccessException | InvocationTargetException e) {                e.printStackTrace();                throw new UnsupportedOperationException("ListPage reflect error", e);            }            ObjectParams result = new ObjectParams(object, keyMethod, setMethod, ids);            result.setParent(parent);            return result;        }    }    private static class Page{        private long timeDoneDate = 30 * 1000;        private long timeNewLoad = 0;        private boolean hasData = false;        private Status state = Status.NOT_LOAD;        Page(long timeDoneDate){            this.timeDoneDate = timeDoneDate;        }        Page(Status state){            this.state = state;            this.timeNewLoad = Long.MAX_VALUE;        }        public void setState(Status state){            if(state == Status.DONE){                this.timeNewLoad = System.currentTimeMillis() + timeDoneDate;            }            this.state = state;        }        public Status getState(){ testPageState(); return state; }        public void setTimeNewLoad(long time){ this.timeNewLoad = time; }        public long getTimeNewLoad(){ testPageState(); return timeNewLoad; }        public boolean hasData(){ testPageState(); return hasData; }        private void testPageState(){            if(state == Status.DONE && timeNewLoad < System.currentTimeMillis()){                state = Status.OUTDATED;            }            if(state == Status.DONE || state == Status.OUTDATED){                hasData = true;            }        }    }}