package ru.vuchobe.util;import android.util.Log;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.net.SocketException;import java.util.ArrayList;import androidx.annotation.NonNull;import ru.vuchobe.BuildConfig;import ru.vuchobe.util.threadUtil.IThreadTask;import ru.vuchobe.util.threadUtil.ThreadService;import ru.vuchobe.util.threadUtil.ThreadTask;public final class NetworkUtils {    public static IThreadTask loadStream(@NonNull InputStream inputStream, @NonNull LoadBytes loaded) {        try {            if (inputStream instanceof ByteArrayInputStream) {                byte[] v = new byte[inputStream.available()];                inputStream.read(v);                loaded._load(v,0 , v.length);                return (ThreadTask task) ->{                    loaded.finish();                    task.stop();                };            } else {                int l = 0;                if (inputStream instanceof ProgressInputStream) {                    l = (int) ((ProgressInputStream) inputStream).getSizeData();                }                final int lenght = l;                final Object blockBuff = new Object();                final byte[] buff = new byte[10240];                return (ThreadTask task) -> {                    try {                        if (lenght > 0 && lenght == loaded.getReads()) {                            finishLoadStream(task, inputStream, loaded, lenght);                            return;                        } /*else if (lenght > 0 && inputStream.available() == 0) {                            return;                        }*/ else if (inputStream.available() > 0) {                            synchronized (blockBuff) {                                while (inputStream.available() > 0) {                                    int len = inputStream.available();                                    if (len > 10240) len = 10240;                                    len = inputStream.read(buff, 0, len);                                    if (len < 0) {                                        finishLoadStream(task, inputStream, loaded, lenght);                                        return;                                    }                                    loaded._load(buff, 0, len);                                }                            }                        } else {                            synchronized (blockBuff) {                                int byteValue = inputStream.read();                                if (byteValue < 0) {                                    finishLoadStream(task, inputStream, loaded, lenght);                                    return;                                }                                buff[0] = (byte) byteValue;                                loaded._load(buff, 0 , 1);                            }                        }                    } catch (IOException e) {                        e.printStackTrace();                        try {inputStream.close();} catch (IOException ex) {}                        loaded.fail(e);                        task.stop();                    }                };            }        } catch (IOException e) {            e.printStackTrace();            try {inputStream.close(); } catch (IOException ex) { }            return (ThreadTask task) -> {                loaded.fail(e);                task.stop();            };        }    }    private static void finishLoadStream(ThreadTask task, InputStream inputStream, LoadBytes loaded, int lenght){        try { inputStream.close(); } catch (IOException ex) {}        if(lenght <= 0 || lenght == loaded.getReads()) {            loaded.finish();        }else{            loaded.fail(new SocketException("Disconnect"));        }        task.stop();    }    public static abstract class LoadBytes{        int reads = 0;        void _load(byte[] bytes, int start, int count){            if(count > 0) reads += count;            load(bytes, start, count);        }        public abstract void load(byte[] bytes, int start, int count);        public abstract void finish();        public abstract void fail(Exception ex);        public int getReads(){            return reads;        }    }    public static class ProgressInputStream extends BufferedInputStream {        ThreadTask task;        long sizeData;        long progressStart = 0;        long position = 0;        boolean isUpdate;        ArrayList<LoadBytes> eventLoad = new ArrayList<>();        byte[] b = new byte[1];        public ProgressInputStream(InputStream input, long size) {            super(input);            task = ThreadService.get();            if(input instanceof ByteArrayInputStream){                try{ sizeData = input.available(); } catch (IOException e) {}            }            sizeData = size;            if (task != null) {                progressStart = task.getProgress();                task.setProgressMax(task.getProgressMax() + ((sizeData > 0) ? sizeData : 100L));            }            isUpdate = task != null && sizeData > 0;        }        @Override        public synchronized int read() throws IOException {            try {                int result = super.read();                if (result >= 0 && isUpdate) {                    position++;                    task.setProgress(task.getProgress() + position);                }                if (result >= 0) {                    b[0] = (byte) result;                    eventReads(b, 0, 1);                }                if (BuildConfig.DEBUG) Log.d("ProgressInputStream", "read() position = " + position + " sizeData = " + sizeData);                return result;            }catch (IOException e){                eventFail(e);                throw e;            }        }        @Override        public int read(byte[] b) throws IOException {            return read(b, 0, b.length);        }        @Override        public synchronized int read(byte[] b, int off, int len) throws IOException {            try {                int length = super.read(b, off, len);                if (length > 0 && isUpdate) {                    position += length;                    task.setProgress(task.getProgress() + position);                }                eventReads(b, off, length);                if (BuildConfig.DEBUG) Log.d("ProgressInputStream", "read() position = " + position + " sizeData = " + sizeData);                return length;            }catch (IOException e){                eventFail(e);                throw e;            }        }        @Override        public synchronized long skip(long n) throws IOException {            try {                long length = super.skip(n);                if (length > 0 && isUpdate) {                    position += length;                    task.setProgress(progressStart + position);                }                if (BuildConfig.DEBUG) Log.d("ProgressInputStream", "skip() position = " + position + " sizeData = " + sizeData);                return length;            }catch (IOException e){                eventFail(e);                throw e;            }        }        @Override        public synchronized void reset() throws IOException {            try {                if (markpos > 0 && isUpdate) {                    task.setProgress(task.getProgress() + markpos - pos);                }                if (BuildConfig.DEBUG) Log.d("ProgressInputStream", "reset() position = " + position + " sizeData = " + sizeData);                super.reset();            }catch (IOException e){                eventFail(e);                throw e;            }        }        @Override        public void close() throws IOException {            if (task != null) {                task.setProgressMax(progressStart + position);                task.setProgress(task.getProgressMax());            }            if (BuildConfig.DEBUG) Log.d("ProgressInputStream", "close() position = " + position + " sizeData = " + sizeData);            eventFinish();            super.close();        }        public void addEventLoad(LoadBytes event){            eventLoad.add(event);        }        public long getSizeData(){            return sizeData;        }        private void eventReads(byte[] bytes, int start, int len){            for(LoadBytes loaded : eventLoad){                loaded.load(bytes, start, len);            }        }        private void eventFinish(){            for(LoadBytes loaded : eventLoad){                loaded.finish();            }            eventLoad.clear();        }        private void eventFail(Exception e){            for(LoadBytes loaded : eventLoad){                loaded.fail(e);            }            eventLoad.clear();        }    }}