package ru.vuchobe.util.loaders;import java.lang.reflect.Method;import java.util.Collections;import java.util.List;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import ru.vuchobe.util.StoreLastArrayList;import ru.vuchobe.util.threadUtil.ThreadLooper;public abstract class PageSaveResult<ResponseBody, Value> extends PageLoader<ResponseBody, Value> implements SaveResult<ResponseBody, Value> {    protected Method methodKeyLoad;    protected Method methodSetLoad;    protected List<SaveResult> loaders;    protected ResponseBody responseBody;    protected List<Page<Value>> pages;    public PageSaveResult(        ThreadLooper looper,        long size,        @Nullable Method methodKeyLoad,        @Nullable Method methodSetLoad,        @Nullable PageLoader<ResponseBody, Value> longLoader,        @Nullable List<SaveResult> loaders,        long timeDoneData,        int savePage    ){        super(looper, size, longLoader, timeDoneData);        this.methodKeyLoad = methodKeyLoad;        this.methodSetLoad = methodSetLoad;        this.loaders = loaders;        if(this.loaders != null){            for(SaveResult loader : this.loaders){                loader.setParent(this);            }        }else{            this.loaders = Collections.EMPTY_LIST;        }        if(savePage < 0) savePage = 64;        if(savePage > 1024) savePage = 1024;        pages = StoreLastArrayList.create(savePage);    }    @Nullable    public ResponseBody getValue(){        if(responseBody == null){            load(buildParams().setPage(0).setSize(size).build());        }        return responseBody;    }    @Nullable    public Value getValue(long position){        long pagePosition = (position / size);        long positionInPage = position % size;        if(this.pages.size() > pagePosition){            Page<Value> page = this.pages.get((int) pagePosition);            if(page != null){                if(page.getState() == Status.NOT_LOAD || page.getState() == Status.OUTDATED){                    load(buildParams().setPage(pagePosition).setSize(size).build());                }                List<Value> values = page.getValues();                if(values != null && positionInPage < values.size()){                    Value value = values.get((int) positionInPage);                    if(value != null){                        if(value instanceof ResultClonable) {                            value = (Value) ((ResultClonable)value).clone();                        }                        Params params = buildParams().setPage(pagePosition).setSize(size).build();                        //Объединение результата                        for (SaveResult saveResult : this.loaders) {                            Params newParams = saveResult.buildParams()                                    .setObject(value)                                    .setKeyMethod(saveResult.getKeyMethod())                                    .setSetMethod(saveResult.getSetMethod())                                    .setParent(params)                                    .build();                            saveResult.getValue(newParams);                        }                        return value;                    }                }            }        }        load(buildParams().setPage(pagePosition).setSize(size).build());        return null;    }    @Nullable    public abstract long size();    @Override    public Status getStatusValue(){        return (responseBody == null)? Status.NOT_LOAD : Status.OUTDATED;    }    @Override    public Status getStatusValue(Params params) {        PageParams pageParams = assertPageParams(params);        if(this.pages.size() > pageParams.getPage()){            Page page = this.pages.get((int)pageParams.getPage());            return page.getState();        }        return Status.NOT_LOAD;    }    @Nullable    @Override    public Value getValue(Params params) {        throw new UnsupportedOperationException("PageSaveResult не поддерживает getValue(params)");    }    @Override    public void load(Params params) {        PageLoader longLoader = this.longLoader;        if(longLoader != null){            longLoader.load(params);        }else{            throw new UnsupportedOperationException("PageSaveResult не поддерживает загрузку данных, установите longLoader");        }    }    @Override    protected void load() { }    @Override    protected void load(long page, long size, Params params, @NonNull CallbackResult<ResponseBody, Value> callback) {}    @Override    public void save(            @Nullable Loader loader,            @Nullable Params params,            @Nullable ResponseBody responseBody,            @NonNull List<Value> values    ) {        if(params instanceof PageParams) {            //updateData            PageParams pageParams = (PageParams) params;            while (pages.size() <= pageParams.getPage()) {                pages.add(new Page<>(this.timeDoneData));            }            Page<Value> page = pages.get((int) pageParams.getPage());            page.setValues(values);            page.setState(Status.DONE);            if(responseBody != null){ this.responseBody = responseBody; }            //LoadValues all            for(Value v : values) {                for (SaveResult saveResult : this.loaders) {                    Params newParams = saveResult.buildParams()                            .setObject(v)                            .setKeyMethod(saveResult.getKeyMethod())                            .setSetMethod(saveResult.getSetMethod())                            .setParent(params)                            .build();                    saveResult.load(newParams);                }            }        }    }    @Override    public void updateDataUI(@Nullable Loader loader, @Nullable Params params) {        super.updateDataUI(loader, params);    }    @Override    public void start() {        super.start();        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.start();            }        }        synchronized (pages){            for(Page page : pages){                if(page != null){                    boolean isData = (page.getValues() != null && !page.getValues().isEmpty());                    page.setState(isData? Status.OUTDATED : Status.NOT_LOAD);                }            }        }        load(buildParams().setPage(0).setSize(size).build());    }    @Override    public void pause() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.pause();            }        }        super.pause();    }    @Override    public void stop() {        List<SaveResult> loaders = this.loaders;        if(loaders != null){            for(SaveResult loader : loaders){                loader.stop();            }        }        super.stop();    }    @Override    public Method getKeyMethod() {        return this.methodKeyLoad;    }    @Override    public Method getSetMethod() {        return this.methodSetLoad;    }    private static class Page<T>{        private long timeDoneDate = 30 * 1000;        private long timeNewLoad = 0;        private boolean hasData = false;        private Status state = Status.NOT_LOAD;        private List<T> values = Collections.EMPTY_LIST;        Page(long timeDoneDate){            this.timeDoneDate = timeDoneDate;        }        Page(Status state){            this.state = state;            this.timeNewLoad = Long.MAX_VALUE;        }        public void setState(Status state){            if(state == Status.DONE){                this.timeNewLoad = System.currentTimeMillis() + timeDoneDate;            }            this.state = state;        }        public Status getState(){ testPageState(); return state; }        public void setTimeNewLoad(long time){ this.timeNewLoad = time; }        public long getTimeNewLoad(){ testPageState(); return timeNewLoad; }        public boolean hasData(){ testPageState(); return hasData; }        public void setValues(List<T> values){ this.values = values; }        public List<T> getValues(){ testPageState(); return this.values; }        private void testPageState(){            if(state == Status.DONE && timeNewLoad < System.currentTimeMillis()){                state = Status.OUTDATED;            }            if(state == Status.DONE || state == Status.OUTDATED){                hasData = true;            }        }    }}